package near

import (
    "bytes"
    "fmt"
    "os"
    "strings"
    "indicer/lib/cnst"
    "indicer/lib/dbio"
    "indicer/lib/structs"
    "github.com/dgraph-io/badger/v4"
)

// visualise creates the HTML graph file
func visualise(fid []byte, idmap *structs.ConcMap, db *badger.DB) error {
    fmt.Println("DEBUG: visualise function called")
    
    if idmap == nil {
        return fmt.Errorf("idmap is nil")
    }
    
    data := idmap.GetData()
    fmt.Printf("DEBUG: idmap contains %d relationships\n", len(data))
    
    // If no relationships, still create an empty graph
    if len(data) == 0 {
        fmt.Println("DEBUG: No relationships found, creating empty graph")
    }
    
    err := generateHTMLGraph(fid, idmap)
    if err != nil {
        fmt.Printf("DEBUG: generateHTMLGraph failed: %v\n", err)
        return err
    }
    
    fmt.Println("DEBUG: graph.html generated successfully")
    return nil
}

// generateHTMLGraph creates a simple HTML visualization using vis.js
func generateHTMLGraph(fid []byte, idmap *structs.ConcMap) error {
    // Start building nodes and edges
    var nodes []string
    var edges []string
    
    // Add main file node
    mainID := fmt.Sprintf("node_%x", fid[:8]) // Short hash for ID
    nodes = append(nodes, fmt.Sprintf(`{id: "%s", label: "Main File", color: "#FF6B6B"}`, mainID))
    
    // Add related file nodes
    count := 0
    data := idmap.GetData()
    for id, confidence := range data {
        nodeID := fmt.Sprintf("related_%d", count)
        shortID := string(id)
        if len(shortID) > 16 {
            shortID = shortID[:16] + "..."
        }
        label := fmt.Sprintf("%s (%.1f%%)", shortID, confidence)
        nodes = append(nodes, fmt.Sprintf(`{id: "%s", label: "%s", color: "#4ECDC4"}`, nodeID, label))
        
        // Add edge from main to this node
        edges = append(edges, fmt.Sprintf(`{from: "%s", to: "%s", label: "%.1f%%"}`, mainID, nodeID, confidence))
        count++
    }
    
    // If no relationships, create a single node
    if count == 0 {
        nodes = []string{fmt.Sprintf(`{id: "%s", label: "Main File (No Relationships)", color: "#FF6B6B"}`, mainID)}
        edges = []string{}
    }
    
    // Generate the HTML
    html := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>NeAR Artefact Relation Graph</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        #network {
            width: 100%%;
            height: 800px;
            border: 1px solid #cccccc;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .header {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>NeAR Artefact Relation Graph</h1>
        <p>Generated by DUES</p>
    </div>
    <div id="network"></div>
    <script>
        var nodes = new vis.DataSet([
            %s
        ]);
        var edges = new vis.DataSet([
            %s
        ]);
        var container = document.getElementById('network');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {
            nodes: {
                shape: 'dot',
                size: 20,
                font: {
                    size: 12
                }
            },
            edges: {
                arrows: 'to',
                smooth: true
            },
            physics: {
                enabled: true
            }
        };
        var network = new vis.Network(container, data, options);
    </script>
</body>
</html>`, strings.Join(nodes, ",\n            "), strings.Join(edges, ",\n            "))
    
    // Write to file
    return os.WriteFile("graph.html", []byte(html), 0644)
}

// GetNames retrieves unique names for a file ID from the database
func GetNames(id []byte, db *badger.DB, unique ...bool) (map[string]struct{}, error) {
    var uniqueFlag bool
    if len(unique) > 0 {
        uniqueFlag = unique[0]
    }

    if bytes.HasPrefix(id, []byte(cnst.IdxFileNamespace)) {
        ifile, err := dbio.GetIndexedFile(id, db)
        if err != nil {
            return nil, err
        }
        if uniqueFlag {
            return getUniqueNames(ifile.Names), nil
        }
        return ifile.Names, nil
    }

    if bytes.HasPrefix(id, []byte(cnst.PartiFileNamespace)) {
        pfile, err := dbio.GetPartitionFile(id, db)
        if err != nil {
            return nil, err
        }
        if uniqueFlag {
            return getUniqueNames(pfile.Names), nil
        }
        return pfile.Names, nil
    }

    efile, err := dbio.GetEvidenceFile(id, db)
    if err != nil {
        return nil, err
    }
    return efile.Names, nil
}

// getUniqueNames extracts unique names from a names map
func getUniqueNames(names map[string]struct{}) map[string]struct{} {
    uniqueMap := make(map[string]struct{})
    interimMap := make(map[string]string)

    for name := range names {
        split := strings.Split(name, cnst.DataSeperator)
        if len(split) < 2 {
            continue
        }
        val := split[len(split)-1]
        split = split[:len(split)-1]
        key := strings.Join(split, cnst.DataSeperator)
        interimMap[key] = val
    }

    for inKey, inVal := range interimMap {
        fullName := inKey + cnst.DataSeperator + inVal
        uniqueMap[fullName] = struct{}{}
    }

    return uniqueMap
}
